package flow

import (
	"fmt"
	"strings"

	"github.com/mattermost/mattermost-server/v6/model"
)

type Color string

const (
	ColorDefault Color = "default"
	ColorPrimary Color = "primary"
	ColorSuccess Color = "success"
	ColorGood    Color = "good"
	ColorWarning Color = "warning"
	ColorDanger  Color = "danger"
)

type Button struct {
	Name     string
	Disabled bool
	Style    Color
	OnClick  func(userID string) Name

	Dialog *Dialog
}

type CustomStepBuilder struct {
	step customStep
}

// NewCustomStepBuilder create a new builder for a custom step.
//
// name must be a unique identifier for a step within the plugin.
func NewCustomStepBuilder(name Name, title, message string) *CustomStepBuilder {
	return &CustomStepBuilder{
		step: customStep{
			name:    name,
			title:   title,
			message: message,
		},
	}
}

func (b *CustomStepBuilder) WithColor(color Color) *CustomStepBuilder {
	b.step.color = color

	return b
}

func (b *CustomStepBuilder) WithPretext(text string) *CustomStepBuilder {
	b.step.pretext = text

	return b
}

func (b *CustomStepBuilder) WithButton(button Button) *CustomStepBuilder {
	b.step.buttons = append(b.step.buttons, button)

	return b
}

func (b *CustomStepBuilder) WithImage(path string) *CustomStepBuilder {
	b.step.imagePath = strings.TrimPrefix(path, "/")

	return b
}

func (b *CustomStepBuilder) IsNotEmpty() *CustomStepBuilder {
	b.step.isNotEmpty = true

	return b
}

func (b *CustomStepBuilder) Build() Step {
	return &b.step
}

type customStep struct {
	name    Name
	title   string
	message string

	color     Color
	pretext   string
	imagePath string
	buttons   []Button

	isNotEmpty bool
}

func (s *customStep) Attachment(pluginURL string) Attachment {
	a := Attachment{
		SlackAttachment: s.getAttachment(pluginURL),
		Actions:         s.getActions(pluginURL),
	}

	return a
}

func (s *customStep) getAttachment(pluginURL string) *model.SlackAttachment {
	attachment := &model.SlackAttachment{
		Color:    string(s.color),
		Pretext:  s.pretext,
		Title:    s.title,
		Text:     s.message,
		Fallback: fmt.Sprintf("%s: %s", s.title, s.message),
	}

	if s.imagePath != "" {
		attachment.ImageURL = pluginURL + "/" + s.imagePath
	}

	return attachment
}

func (s *customStep) getActions(pluginURL string) []Action {
	if s.buttons == nil {
		return nil
	}

	var actions []Action
	for i, b := range s.buttons {
		onClick := b.OnClick
		// Avoid using the loop index in nested functions
		j := i

		dialog := b.Dialog

		action := Action{
			PostAction: model.PostAction{
				Type:     model.PostActionTypeButton,
				Name:     b.Name,
				Disabled: b.Disabled,
				Style:    string(b.Style),
			},
			ClickFunc: func(userID string, state State) (Name, Attachment) {
				to := Name("")
				if onClick != nil {
					to = onClick(userID)
				}

				var newActions []Action
				if to == s.name {
					// Keep full list
					newActions = s.getActions(pluginURL)
				} else {
					// Only list the selected one
					action := s.getActions(pluginURL)[j]
					action.Disabled = true
					newActions = []Action{action}
				}

				attachment := Attachment{
					SlackAttachment: s.getAttachment(pluginURL),
					Actions:         newActions,
				}

				return to, attachment
			},
		}

		if dialog != nil {
			action.ClickDialog = &Dialog{
				Dialog: dialog.Dialog,

				OnDialogSubmit: func(userID string, submission map[string]interface{}, state State) (Name, *Attachment, string, map[string]string) {
					to, _, resposeError, resposeErrors := dialog.OnDialogSubmit(userID, submission, state)

					var newActions []Action
					if to == "" || resposeError != "" || len(resposeErrors) != 0 {
						// Keep full list
						newActions = s.getActions(pluginURL)
					} else {
						// Only list the selected one
						newAction := s.getActions(pluginURL)[j]
						newAction.Disabled = true

						newActions = []Action{newAction}
					}

					attachment := &Attachment{
						SlackAttachment: s.getAttachment(pluginURL),
						Actions:         newActions,
					}

					return to, attachment, resposeError, resposeErrors
				},
			}

			if dialog.OnCancel != nil {
				action.ClickDialog.Dialog.NotifyOnCancel = true
				action.ClickDialog.OnCancel = dialog.OnCancel
			} else {
				action.ClickDialog.Dialog.NotifyOnCancel = false
			}
		}

		actions = append(actions, action)
	}

	return actions
}

func (s *customStep) Name() Name {
	return s.name
}

func (s *customStep) IsEmpty() bool {
	if s.isNotEmpty {
		return false
	}

	return len(s.buttons) == 0
}
